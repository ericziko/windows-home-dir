"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VSCodeAzureSubscriptionProvider = void 0;
const vscode = require("vscode");
const getSessionFromVSCode_1 = require("./getSessionFromVSCode");
const NotSignedInError_1 = require("./NotSignedInError");
const configuredAzureEnv_1 = require("./utils/configuredAzureEnv");
const EventDebounce = 5 * 1000; // 5 seconds
/**
 * A class for obtaining Azure subscription information using VSCode's built-in authentication
 * provider.
 */
class VSCodeAzureSubscriptionProvider extends vscode.Disposable {
    // So that customers can easily share logs, try to only log PII using trace level
    constructor(logger) {
        const disposable = vscode.authentication.onDidChangeSessions((e) => __awaiter(this, void 0, void 0, function* () {
            // Ignore any sign in that isn't for the configured auth provider
            if (e.provider.id !== (0, configuredAzureEnv_1.getConfiguredAuthProviderId)()) {
                return;
            }
            if (yield this.isSignedIn()) {
                if (!this.suppressSignInEvents && Date.now() > this.lastSignInEventFired + EventDebounce) {
                    this.lastSignInEventFired = Date.now();
                    this.onDidSignInEmitter.fire();
                }
            }
            else if (Date.now() > this.lastSignOutEventFired + EventDebounce) {
                this.lastSignOutEventFired = Date.now();
                this.onDidSignOutEmitter.fire();
            }
        }));
        super(() => {
            this.onDidSignInEmitter.dispose();
            this.onDidSignOutEmitter.dispose();
            disposable.dispose();
        });
        this.logger = logger;
        this.onDidSignInEmitter = new vscode.EventEmitter();
        this.lastSignInEventFired = 0;
        this.suppressSignInEvents = false;
        this.onDidSignOutEmitter = new vscode.EventEmitter();
        this.lastSignOutEventFired = 0;
        /**
         * An event that is fired when the user signs in. Debounced to fire at most once every 5 seconds.
         */
        this.onDidSignIn = this.onDidSignInEmitter.event;
        /**
         * An event that is fired when the user signs out. Debounced to fire at most once every 5 seconds.
         */
        this.onDidSignOut = this.onDidSignOutEmitter.event;
    }
    /**
     * Gets a list of tenants available to the user.
     * Use {@link isSignedIn} to check if the user is signed in to a particular tenant.
     *
     * @param account (Optional) A specific account to get tenants for. If not provided, all accounts will be used.
     *
     * @returns A list of tenants.
     */
    getTenants(account) {
        var _a, e_1, _b, _c, _d, e_2, _e, _f;
        var _g;
        return __awaiter(this, void 0, void 0, function* () {
            const startTimeMs = Date.now();
            const results = [];
            try {
                for (var _h = true, _j = __asyncValues(account ? [account] : yield vscode.authentication.getAccounts((0, configuredAzureEnv_1.getConfiguredAuthProviderId)())), _k; _k = yield _j.next(), _a = _k.done, !_a;) {
                    _c = _k.value;
                    _h = false;
                    try {
                        account = _c;
                        // Added check. Without this the getSubscriptionClient function throws the NotSignedInError
                        if (yield this.isSignedIn(undefined, account)) {
                            const { client } = yield this.getSubscriptionClient(account, undefined, undefined);
                            try {
                                for (var _l = true, _m = (e_2 = void 0, __asyncValues(client.tenants.list())), _o; _o = yield _m.next(), _d = _o.done, !_d;) {
                                    _f = _o.value;
                                    _l = false;
                                    try {
                                        const tenant = _f;
                                        results.push(Object.assign(Object.assign({}, tenant), { account }));
                                    }
                                    finally {
                                        _l = true;
                                    }
                                }
                            }
                            catch (e_2_1) { e_2 = { error: e_2_1 }; }
                            finally {
                                try {
                                    if (!_l && !_d && (_e = _m.return)) yield _e.call(_m);
                                }
                                finally { if (e_2) throw e_2.error; }
                            }
                        }
                    }
                    finally {
                        _h = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_h && !_a && (_b = _j.return)) yield _b.call(_j);
                }
                finally { if (e_1) throw e_1.error; }
            }
            const endTimeMs = Date.now();
            (_g = this.logger) === null || _g === void 0 ? void 0 : _g.debug(`auth: Got ${results.length} tenants for account "${account === null || account === void 0 ? void 0 : account.label}" in ${endTimeMs - startTimeMs}ms`);
            return results;
        });
    }
    /**
     * Gets a list of Azure subscriptions available to the user.
     *
     * @param filter - Whether to filter the list returned. When:
     * - `true`: according to the list returned by `getTenantFilters()` and `getSubscriptionFilters()`.
     * - `false`: return all subscriptions.
     * - `GetSubscriptionsFilter`: according to the values in the filter.
     *
     * Optional, default true.
     *
     * @returns A list of Azure subscriptions. The list is sorted by subscription name.
     * The list can contain duplicate subscriptions if they come from different accounts.
     *
     * @throws A {@link NotSignedInError} If the user is not signed in to Azure.
     * Use {@link isSignedIn} and/or {@link signIn} before this method to ensure
     * the user is signed in.
     */
    getSubscriptions(filter = true) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.debug('auth: Loading subscriptions...');
            const startTime = Date.now();
            const configuredTenantFilter = yield this.getTenantFilters();
            const tenantIdsToFilterBy = 
            // Only filter by the tenant ID option if it is provided
            (typeof filter === 'object' && filter.tenantId ? [filter.tenantId] :
                // Only filter by the configured filter if `filter` is true AND there are tenants in the configured filter
                filter === true && configuredTenantFilter.length > 0 ? configuredTenantFilter :
                    undefined);
            const allSubscriptions = [];
            let accountCount; // only used for logging
            try {
                this.suppressSignInEvents = true;
                // Get the list of tenants from each account (filtered or all)
                const accounts = typeof filter === 'object' && filter.account ? [filter.account] : yield vscode.authentication.getAccounts((0, configuredAzureEnv_1.getConfiguredAuthProviderId)());
                accountCount = accounts.length;
                for (const account of accounts) {
                    for (const tenant of yield this.getTenants(account)) {
                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        const tenantId = tenant.tenantId;
                        if ((tenantIdsToFilterBy === null || tenantIdsToFilterBy === void 0 ? void 0 : tenantIdsToFilterBy.includes(tenantId)) === false) {
                            continue;
                        }
                        // For each tenant, get the list of subscriptions
                        allSubscriptions.push(...yield this.getSubscriptionsForTenant(account, tenantId));
                    }
                    // list subscriptions for the home tenant
                    allSubscriptions.push(...yield this.getSubscriptionsForTenant(account));
                }
            }
            finally {
                this.suppressSignInEvents = false;
            }
            // It's possible that by listing subscriptions in all tenants and the "home" tenant there could be duplicate subscriptions
            // Thus, we remove duplicate subscriptions. However, if multiple accounts have the same subscription, we keep them.
            const subscriptionMap = new Map();
            allSubscriptions.forEach(sub => subscriptionMap.set(`${sub.account.id}/${sub.subscriptionId}`, sub));
            const uniqueSubscriptions = Array.from(subscriptionMap.values());
            const endTime = Date.now();
            (_b = this.logger) === null || _b === void 0 ? void 0 : _b.debug(`auth: Got ${uniqueSubscriptions.length} subscriptions from ${accountCount} accounts in ${endTime - startTime}ms`);
            const sortSubscriptions = (subscriptions) => subscriptions.sort((a, b) => a.name.localeCompare(b.name));
            const subscriptionIds = yield this.getSubscriptionFilters();
            if (filter === true && !!subscriptionIds.length) { // If the list is empty it is treated as "no filter"
                return sortSubscriptions(uniqueSubscriptions.filter(sub => subscriptionIds.includes(sub.subscriptionId)));
            }
            return sortSubscriptions(uniqueSubscriptions);
        });
    }
    /**
     * Checks to see if a user is signed in.
     *
     * @param tenantId (Optional) Provide to check if a user is signed in to a specific tenant.
     * @param account (Optional) Provide to check if a user is signed in to a specific account.
     *
     * @returns True if the user is signed in, false otherwise.
     *
     * If no tenant or account is provided, then
     * checks all accounts for a session.
     */
    isSignedIn(tenantId, account) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            function silentlyCheckForSession(tenantId, account) {
                return __awaiter(this, void 0, void 0, function* () {
                    return !!(yield (0, getSessionFromVSCode_1.getSessionFromVSCode)([], tenantId, { createIfNone: false, silent: true, account }));
                });
            }
            const innerIsSignedIn = () => __awaiter(this, void 0, void 0, function* () {
                // If no tenant or account is provided, then check all accounts for a session
                if (!account && !tenantId) {
                    const accounts = yield vscode.authentication.getAccounts((0, configuredAzureEnv_1.getConfiguredAuthProviderId)());
                    if (accounts.length === 0) {
                        return false;
                    }
                    for (const account of accounts) {
                        if (yield silentlyCheckForSession(tenantId, account)) {
                            // If any account has a session, then return true because the user is signed in
                            return true;
                        }
                    }
                }
                return silentlyCheckForSession(tenantId, account);
            });
            const result = yield innerIsSignedIn();
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.trace(`auth: isSignedIn returned ${result} (account="${(_b = account === null || account === void 0 ? void 0 : account.label) !== null && _b !== void 0 ? _b : 'none'}") (tenantId="${tenantId !== null && tenantId !== void 0 ? tenantId : 'none'}")`);
            return result;
        });
    }
    /**
     * Asks the user to sign in or pick an account to use.
     *
     * @param tenantId (Optional) Provide to sign in to a specific tenant.
     * @param account (Optional) Provide to sign in to a specific account.
     *
     * @returns True if the user is signed in, false otherwise.
     */
    signIn(tenantId, account) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.debug(`auth: Signing in (account="${(_b = account === null || account === void 0 ? void 0 : account.label) !== null && _b !== void 0 ? _b : 'none'}") (tenantId="${tenantId !== null && tenantId !== void 0 ? tenantId : 'none'}")`);
            const session = yield (0, getSessionFromVSCode_1.getSessionFromVSCode)([], tenantId, {
                createIfNone: true,
                // If no account is provided, then clear the session preference which tells VS Code to show the account picker
                clearSessionPreference: !account,
                account,
            });
            return !!session;
        });
    }
    /**
     * Signs the user out
     *
     * @deprecated Not currently supported by VS Code auth providers
     */
    signOut() {
        throw new Error(vscode.l10n.t('Signing out programmatically is not supported. You must sign out by selecting the account in the Accounts menu and choosing Sign Out.'));
    }
    /**
     * Gets the tenant filters that are configured in `azureResourceGroups.selectedSubscriptions`. To
     * override the settings with a custom filter, implement a child class with `getSubscriptionFilters()`
     * and/or `getTenantFilters()` overridden.
     *
     * If no values are returned by `getTenantFilters()`, then all tenants will be scanned for subscriptions.
     *
     * @returns A list of tenant IDs that are configured in `azureResourceGroups.selectedSubscriptions`.
     */
    getTenantFilters() {
        return __awaiter(this, void 0, void 0, function* () {
            const config = vscode.workspace.getConfiguration('azureResourceGroups');
            const fullSubscriptionIds = config.get('selectedSubscriptions', []);
            return fullSubscriptionIds.map(id => id.split('/')[0]);
        });
    }
    /**
     * Gets the subscription filters that are configured in `azureResourceGroups.selectedSubscriptions`. To
     * override the settings with a custom filter, implement a child class with `getSubscriptionFilters()`
     * and/or `getTenantFilters()` overridden.
     *
     * If no values are returned by `getSubscriptionFilters()`, then all subscriptions will be returned.
     *
     * @returns A list of subscription IDs that are configured in `azureResourceGroups.selectedSubscriptions`.
     */
    getSubscriptionFilters() {
        return __awaiter(this, void 0, void 0, function* () {
            const config = vscode.workspace.getConfiguration('azureResourceGroups');
            const fullSubscriptionIds = config.get('selectedSubscriptions', []);
            return fullSubscriptionIds.map(id => id.split('/')[1]);
        });
    }
    /**
     * Gets the subscriptions for a given tenant.
     *
     * @param tenantId The tenant ID to get subscriptions for.
     * @param account The account to get the subscriptions for.
     *
     * @returns The list of subscriptions for the tenant.
     */
    getSubscriptionsForTenant(account, tenantId) {
        var _a, e_3, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            // If the user is not signed in to this tenant or account, then return an empty list
            // This is to prevent the NotSignedInError from being thrown in getSubscriptionClient
            if (!(yield this.isSignedIn(tenantId, account))) {
                return [];
            }
            const { client, credential, authentication } = yield this.getSubscriptionClient(account, tenantId, undefined);
            const environment = (0, configuredAzureEnv_1.getConfiguredAzureEnv)();
            const subscriptions = [];
            try {
                for (var _d = true, _e = __asyncValues(client.subscriptions.list()), _f; _f = yield _e.next(), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const subscription = _c;
                        subscriptions.push({
                            authentication: authentication,
                            environment: environment,
                            credential: credential,
                            isCustomCloud: environment.isCustomCloud,
                            /* eslint-disable @typescript-eslint/no-non-null-assertion */
                            name: subscription.displayName,
                            subscriptionId: subscription.subscriptionId,
                            tenantId: tenantId !== null && tenantId !== void 0 ? tenantId : subscription.tenantId,
                            /* eslint-enable @typescript-eslint/no-non-null-assertion */
                            account: account
                        });
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);
                }
                finally { if (e_3) throw e_3.error; }
            }
            return subscriptions;
        });
    }
    /**
     * Gets a fully-configured subscription client for a given tenant ID
     *
     * @param tenantId (Optional) The tenant ID to get a client for
     * @param account The account that you would like to get the session for
     *
     * @returns A client, the credential used by the client, and the authentication function
     */
    getSubscriptionClient(account, tenantId, scopes) {
        return __awaiter(this, void 0, void 0, function* () {
            const armSubs = yield Promise.resolve().then(() => require('@azure/arm-resources-subscriptions'));
            const session = yield (0, getSessionFromVSCode_1.getSessionFromVSCode)(scopes, tenantId, { createIfNone: false, silent: true, account });
            if (!session) {
                throw new NotSignedInError_1.NotSignedInError();
            }
            const credential = {
                getToken: () => __awaiter(this, void 0, void 0, function* () {
                    return {
                        token: session.accessToken,
                        expiresOnTimestamp: 0
                    };
                })
            };
            const configuredAzureEnv = (0, configuredAzureEnv_1.getConfiguredAzureEnv)();
            const endpoint = configuredAzureEnv.resourceManagerEndpointUrl;
            return {
                client: new armSubs.SubscriptionClient(credential, { endpoint }),
                credential: credential,
                authentication: {
                    getSession: () => session,
                    getSessionWithScopes: (scopes) => {
                        return (0, getSessionFromVSCode_1.getSessionFromVSCode)(scopes, tenantId, { createIfNone: false, silent: true, account });
                    },
                }
            };
        });
    }
}
exports.VSCodeAzureSubscriptionProvider = VSCodeAzureSubscriptionProvider;
//# sourceMappingURL=VSCodeAzureSubscriptionProvider.js.map